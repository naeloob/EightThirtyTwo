FIXME - Printf in hex mode is screwy.  Look at remainders of negative numbers.

DONE Look at potential little endian mode

DONE Add another overloaded instruction for a halfword modifier

DONE Implement interrupts

* Look at fusing mr with li, and potentially addt.

* Results forwarding?

DONE  GHDL - can we integrate a proper UART emulation and print results to the Shell window?
      (Sort of - have to write a line at a time.)

DONE  Look at multithreading.  Would need a second register file, a second PC and a second fetch channel.
      The second thread would launch with the C flag set, so startup code can tell whether it's dealing with
      Thread 1, Thread 2 or an interrupt.

DONE C backend - get signed-ness, composite types and halfword / byte operations working.

* Look at the instruction set again.
	* stinc?
	* Can we adjust pre/postinc based on byt/hlf directives?  Potentially - would need to bring in the
	  increment value through the imm channel?  Might be a worthwhile simplification anyway.

* Look at integrating tmp register in the ALU itself.  (Might be tricky due to dual-threading.)

Code generator needs a further intermediate format.

struct e32obj
{
	struct e32obj *next,*prev;
	int uid;
	char *identifier;
	int offset;
	int type;	// Can use the existing extern / static / auto flags + maybe an immediate type too?  + function type
	struct e32op *first;	// If a function, this is a string of instructions.
};

Create one of these for each function, static object, external object (and stack variable?)

struct e32op
{
	struct e32op *next,*prev;
	enum e32opcode op;
	int reg;
	char *identifier;
	int offset;
	struct e32obj *obj;
};

When generating the code for a function, generate one of these for each opcode.

Need to model the register set and stack, keeping track of which object (and offset) is held in each.

